import{L as _,D as N}from"./@open-draft-BbAaxlxc.js";import{E as R}from"./strict-event-emitter-CrFXw_VT.js";import{i as d}from"./outvariant-BBS2yBlX.js";function G(e){const t=Object.getOwnPropertyDescriptor(globalThis,e);return typeof t>"u"||typeof t.get=="function"&&typeof t.get()>"u"||typeof t.get>"u"&&t.value==null?!1:typeof t.set>"u"&&!t.configurable?(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1):!0}function I(e){return globalThis[e]||void 0}function A(e,t){globalThis[e]=t}function M(e){delete globalThis[e]}var x=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new R,this.subscriptions=[],this.logger=new _(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const e=this.logger.extend("apply");if(e.info("applying the interceptor..."),this.readyState==="APPLIED"){e.info("intercepted already applied!");return}if(!this.checkEnvironment()){e.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";const s=this.getInstance();if(s){e.info("found a running instance, reusing..."),this.on=(n,l)=>(e.info('proxying the "%s" listener',n),s.emitter.addListener(n,l),this.subscriptions.push(()=>{s.emitter.removeListener(n,l),e.info('removed proxied "%s" listener!',n)}),this),this.readyState="APPLIED";return}e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){const s=this.logger.extend("on");return this.readyState==="DISPOSING"||this.readyState==="DISPOSED"?(s.info("cannot listen to events, already disposed!"),this):(s.info('adding "%s" event listener:',e,t),this.emitter.on(e,t),this)}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){const e=this.logger.extend("dispose");if(this.readyState==="DISPOSED"){e.info("cannot dispose, already disposed!");return}if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){e.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),e.info("global symbol deleted:",I(this.symbol)),this.subscriptions.length>0){e.info("disposing of %d subscriptions...",this.subscriptions.length);for(const t of this.subscriptions)t();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var e;const t=I(this.symbol);return this.logger.info("retrieved global instance:",(e=t==null?void 0:t.constructor)==null?void 0:e.name),t}setInstance(){A(this.symbol,this),this.logger.info("set global instance!",this.symbol.description)}clearInstance(){M(this.symbol),this.logger.info("cleared global instance!",this.symbol.description)}};function j(){return Math.random().toString(16).slice(2)}function r(e,t){return Object.defineProperties(t,{target:{value:e,enumerable:!0,writable:!0},currentTarget:{value:e,enumerable:!0,writable:!0}}),t}var u=Symbol("kCancelable"),o=Symbol("kDefaultPrevented"),L=class extends MessageEvent{constructor(e,t){super(e,t),this[u]=!!t.cancelable,this[o]=!1}get cancelable(){return this[u]}set cancelable(e){this[u]=e}get defaultPrevented(){return this[o]}set defaultPrevented(e){this[o]=e}preventDefault(){this.cancelable&&!this[o]&&(this[o]=!0)}},m=class extends Event{constructor(e,t={}){super(e,t),this.code=t.code===void 0?0:t.code,this.reason=t.reason===void 0?"":t.reason,this.wasClean=t.wasClean===void 0?!1:t.wasClean}},w=class extends m{constructor(e,t={}){super(e,t),this[u]=!!t.cancelable,this[o]=!1}get cancelable(){return this[u]}set cancelable(e){this[u]=e}get defaultPrevented(){return this[o]}set defaultPrevented(e){this[o]=e}preventDefault(){this.cancelable&&!this[o]&&(this[o]=!0)}},b=Symbol("kEmitter"),S=Symbol("kBoundListener"),B=class{constructor(e,t){this.socket=e,this.transport=t,this.id=j(),this.url=new URL(e.url),this[b]=new EventTarget,this.transport.addEventListener("outgoing",s=>{const n=r(this.socket,new L("message",{data:s.data,origin:s.origin,cancelable:!0}));this[b].dispatchEvent(n),n.defaultPrevented&&s.preventDefault()}),this.transport.addEventListener("close",s=>{this[b].dispatchEvent(r(this.socket,new m("close",s)))})}addEventListener(e,t,s){if(!Reflect.has(t,S)){const n=t.bind(this.socket);Object.defineProperty(t,S,{value:n,enumerable:!1,configurable:!1})}this[b].addEventListener(e,Reflect.get(t,S),s)}removeEventListener(e,t,s){this[b].removeEventListener(e,Reflect.get(t,S),s)}send(e){this.transport.send(e)}close(e,t){this.transport.close(e,t)}},W="InvalidAccessError: close code out of user configurable range",y=Symbol("kPassthroughPromise"),P=Symbol("kOnSend"),g=Symbol("kClose"),v=class extends EventTarget{constructor(e,t){super(),this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null,this.url=e.toString(),this.protocol="",this.extensions="",this.binaryType="blob",this.readyState=this.CONNECTING,this.bufferedAmount=0,this[y]=new N,queueMicrotask(async()=>{await this[y]||(this.protocol=typeof t=="string"?t:Array.isArray(t)&&t.length>0?t[0]:"",this.readyState===this.CONNECTING&&(this.readyState=this.OPEN,this.dispatchEvent(r(this,new Event("open")))))})}set onopen(e){this.removeEventListener("open",this._onopen),this._onopen=e,e!==null&&this.addEventListener("open",e)}get onopen(){return this._onopen}set onmessage(e){this.removeEventListener("message",this._onmessage),this._onmessage=e,e!==null&&this.addEventListener("message",e)}get onmessage(){return this._onmessage}set onerror(e){this.removeEventListener("error",this._onerror),this._onerror=e,e!==null&&this.addEventListener("error",e)}get onerror(){return this._onerror}set onclose(e){this.removeEventListener("close",this._onclose),this._onclose=e,e!==null&&this.addEventListener("close",e)}get onclose(){return this._onclose}send(e){if(this.readyState===this.CONNECTING)throw this.close(),new DOMException("InvalidStateError");this.readyState===this.CLOSING||this.readyState===this.CLOSED||(this.bufferedAmount+=U(e),queueMicrotask(()=>{var t;this.bufferedAmount=0,(t=this[P])==null||t.call(this,e)}))}close(e=1e3,t){d(e,W),d(e===1e3||e>=3e3&&e<=4999,W),this[g](e,t)}[g](e=1e3,t,s=!0){this.readyState===this.CLOSING||this.readyState===this.CLOSED||(this.readyState=this.CLOSING,queueMicrotask(()=>{this.readyState=this.CLOSED,this.dispatchEvent(r(this,new m("close",{code:e,reason:t,wasClean:s}))),this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null}))}addEventListener(e,t,s){return super.addEventListener(e,t,s)}removeEventListener(e,t,s){return super.removeEventListener(e,t,s)}};v.CONNECTING=0;v.OPEN=1;v.CLOSING=2;v.CLOSED=3;function U(e){return typeof e=="string"?e.length:e instanceof Blob?e.size:e.byteLength}var c=Symbol("kEmitter"),E=Symbol("kBoundListener"),C=Symbol("kSend"),q=class{constructor(e,t,s){this.client=e,this.transport=t,this.createConnection=s,this[c]=new EventTarget,this.mockCloseController=new AbortController,this.realCloseController=new AbortController,this.transport.addEventListener("outgoing",n=>{typeof this.realWebSocket>"u"||queueMicrotask(()=>{n.defaultPrevented||this[C](n.data)})}),this.transport.addEventListener("incoming",this.handleIncomingMessage.bind(this))}get socket(){return d(this.realWebSocket,'Cannot access "socket" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'),this.realWebSocket}connect(){d(!this.realWebSocket||this.realWebSocket.readyState!==WebSocket.OPEN,'Failed to call "connect()" on the original WebSocket instance: the connection already open');const e=this.createConnection();e.binaryType=this.client.binaryType,e.addEventListener("open",t=>{this[c].dispatchEvent(r(this.realWebSocket,new Event("open",t)))},{once:!0}),e.addEventListener("message",t=>{this.transport.dispatchEvent(r(this.realWebSocket,new MessageEvent("incoming",{data:t.data,origin:t.origin})))}),this.client.addEventListener("close",t=>{this.handleMockClose(t)},{signal:this.mockCloseController.signal}),e.addEventListener("close",t=>{this.handleRealClose(t)},{signal:this.realCloseController.signal}),e.addEventListener("error",()=>{const t=r(e,new Event("error",{cancelable:!0}));this[c].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(r(this.client,new Event("error")))}),this.realWebSocket=e}addEventListener(e,t,s){if(!Reflect.has(t,E)){const n=t.bind(this.client);Object.defineProperty(t,E,{value:n,enumerable:!1})}this[c].addEventListener(e,Reflect.get(t,E),s)}removeEventListener(e,t,s){this[c].removeEventListener(e,Reflect.get(t,E),s)}send(e){this[C](e)}[C](e){const{realWebSocket:t}=this;if(d(t,'Failed to call "server.send()" for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),!(t.readyState===WebSocket.CLOSING||t.readyState===WebSocket.CLOSED)){if(t.readyState===WebSocket.CONNECTING){t.addEventListener("open",()=>{t.send(e)},{once:!0});return}t.send(e)}}close(){const{realWebSocket:e}=this;d(e,'Failed to close server connection for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),this.realCloseController.abort(),!(e.readyState===WebSocket.CLOSING||e.readyState===WebSocket.CLOSED)&&(e.close(),queueMicrotask(()=>{this[c].dispatchEvent(r(this.realWebSocket,new w("close",{code:1e3,cancelable:!0})))}))}handleIncomingMessage(e){const t=r(e.target,new L("message",{data:e.data,origin:e.origin,cancelable:!0}));this[c].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(r(this.client,new MessageEvent("message",{data:e.data,origin:e.origin})))}handleMockClose(e){this.realWebSocket&&this.realWebSocket.close()}handleRealClose(e){this.mockCloseController.abort();const t=r(this.realWebSocket,new w("close",{code:e.code,reason:e.reason,wasClean:e.wasClean,cancelable:!0}));this[c].dispatchEvent(t),t.defaultPrevented||this.client[g](e.code,e.reason)}},F=class extends EventTarget{constructor(e){super(),this.socket=e,this.socket.addEventListener("close",t=>{this.dispatchEvent(r(this.socket,new m("close",t)))}),this.socket[P]=t=>{this.dispatchEvent(r(this.socket,new L("outgoing",{data:t,origin:this.socket.url,cancelable:!0})))}}addEventListener(e,t,s){return super.addEventListener(e,t,s)}dispatchEvent(e){return super.dispatchEvent(e)}send(e){queueMicrotask(()=>{if(this.socket.readyState===this.socket.CLOSING||this.socket.readyState===this.socket.CLOSED)return;const t=()=>{this.socket.dispatchEvent(r(this.socket,new MessageEvent("message",{data:e,origin:this.socket.url})))};this.socket.readyState===this.socket.CONNECTING?this.socket.addEventListener("open",()=>{t()},{once:!0}):t()})}close(e,t){this.socket[g](e,t)}},D=class extends x{constructor(){super(D.symbol)}checkEnvironment(){return G("WebSocket")}setup(){const e=Object.getOwnPropertyDescriptor(globalThis,"WebSocket"),t=new Proxy(globalThis.WebSocket,{construct:(s,n,l)=>{const[k,f]=n,p=()=>Reflect.construct(s,n,l),i=new v(k,f),O=new F(i);return queueMicrotask(()=>{try{const a=new q(i,O,p);this.emitter.emit("connection",{client:new B(i,O),server:a,info:{protocols:f}})?i[y].resolve(!1):(i[y].resolve(!0),a.connect(),a.addEventListener("open",()=>{i.dispatchEvent(r(i,new Event("open"))),a.realWebSocket&&(i.protocol=a.realWebSocket.protocol)}))}catch(a){a instanceof Error&&(i.dispatchEvent(new Event("error")),i.readyState!==WebSocket.CLOSING&&i.readyState!==WebSocket.CLOSED&&i[g](1011,a.message,!1),console.error(a))}}),i}});Object.defineProperty(globalThis,"WebSocket",{value:t,configurable:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis,"WebSocket",e)})}},H=D;H.symbol=Symbol("websocket");new TextEncoder;var h=class extends Response{static isConfigurableStatusCode(e){return e>=200&&e<=599}static isRedirectResponse(e){return h.STATUS_CODES_WITH_REDIRECT.includes(e)}static isResponseWithBody(e){return!h.STATUS_CODES_WITHOUT_BODY.includes(e)}static setUrl(e,t){e&&t.url==""&&Object.defineProperty(t,"url",{value:e,enumerable:!0,configurable:!0,writable:!1})}static parseRawHeaders(e){const t=new Headers;for(let s=0;s<e.length;s+=2)t.append(e[s],e[s+1]);return t}constructor(e,t={}){var s;const n=(s=t.status)!=null?s:200,l=h.isConfigurableStatusCode(n)?n:200,k=h.isResponseWithBody(n)?e:null;if(super(k,{...t,status:l}),n!==l){const f=Object.getOwnPropertySymbols(this).find(p=>p.description==="state");if(f){const p=Reflect.get(this,f);Reflect.set(p,"status",n)}else Object.defineProperty(this,"status",{value:n,enumerable:!0,configurable:!0,writable:!1})}h.setUrl(t.url,this)}},T=h;T.STATUS_CODES_WITHOUT_BODY=[101,103,204,205,304];T.STATUS_CODES_WITH_REDIRECT=[301,302,303,307,308];function $(e,t=!0){return[t&&e.origin,e.pathname].filter(Boolean).join("")}export{T as F,H as W,$ as g};
